#################################################
# Additional constructors
#################################################

# These two constructors will hopefully be in the next Oscar release
normal_toric_variety(rays::Oscar.AbstractCollection[RayVector], max_cones::Vector{Vector{Int64}}; non_redundant::Bool = false) = 
normal_toric_variety(rays, IncidenceMatrix(max_cones); non_redundant = non_redundant)

function normal_toric_variety(rays::Oscar.AbstractCollection[RayVector], max_cones::IncidenceMatrix; non_redundant::Bool = false)
  fan = polyhedral_fan(rays, max_cones; non_redundant=non_redundant)
  return normal_toric_variety(fan)
end

# A constructor for normal toric varieties of picard number one.
# The fan will be the unique complete fan having `transpose(P)` as its generator matrix.
function normal_toric_variety(P :: MatElem)
    n, r = nrows(P), ncols(P)
    @req n == r + 1 "this constructor only works if the picard rank is one"
    cones = collect(powerset(1 : n, r, r))
    normal_toric_variety(P, cones)
end


@attr function affine_toric_charts(X :: AbstractNormalToricVariety)
    P = gen_matrix(X)
    charts = Dict{Vector{Int}, AffineNormalToricVariety}()
    for c in maximal_cones_indices(X)
        charts[c] = affine_normal_toric_variety(cone(transpose(P[:, c])))
    end
    return charts
end

# return the affine toric chart associated with the given cone
affine_toric_chart(X :: AbstractNormalToricVariety, c :: Vector{Int64}) = affine_toric_charts(X)[c]

# remove the torus factor of a toric variety.
# This means using the rational vector space generated by the rays of the fan
# as its ambient space.
function remove_torusfactor(X :: AbstractNormalToricVariety)
    P = gen_matrix(X)
    r, A, _ = rcef_rational(P)
    A = A[:, 1 : r]
    # Use `invoke` here to dispatch on the more generic `solve_rational` from 
    # AbstractAlgebra, which doesn't require the first argument to be a square matrix
    new_P, _ = invoke(solve_rational, Tuple{MatElem{ZZRingElem}, MatElem{ZZRingElem}}, A, P)
    normal_toric_variety(transpose(new_P), maximal_cones_indices(X))
end


#################################################
# Some basis attributes
#################################################

@attr gen_matrix(X :: AbstractNormalToricVariety) = transpose(matrix(ZZ, rays(X)))

@attr function maximal_cones_indices(X :: AbstractNormalToricVariety) 
    IM = ray_indices(maximal_cones(X))
    [sort(collect(row(IM,i))) for i = 1 : nrows(IM)]
end

@attr covering_collection(X :: AbstractNormalToricVariety) =
map(c -> [i for i in 1 : nrays(X) if i âˆ‰ c], maximal_cones_indices(X))

@attr degree_matrix(X :: AbstractNormalToricVariety) =
transpose(vcat([w.coeff for w in Oscar._cox_ring_weights(X)]))

@attr function degree_matrix_torsion_part(X :: AbstractNormalToricVariety)
    Q = degree_matrix(X)
    Q[1 : end - rank(class_group(X)), :]
end

@attr function degree_matrix_free_part(X :: AbstractNormalToricVariety)
    Q = degree_matrix(X)
    Q[end - rank(class_group(X)) + 1 : end, :]
end

@attr is_q_factorial(X :: AbstractNormalToricVariety) = is_simplicial(X)

@attr is_factorial(X :: AbstractNormalToricVariety) = is_smooth(X)

#overwritten from Oscar
@attr is_fano(X :: AbstractNormalToricVariety) = is_ample(anticanonical_divisor_class(X))


#################################################
# Gorentein index and Picard index
#################################################

@attr GrpAbFinGenMap function map_from_torusinvariant_cartier_divisor_group_to_class_group(v::AbstractNormalToricVariety)
    # check input
    if has_torusfactor(v)
        throw(ArgumentError("Group of the torus-invariant Cartier divisors can only be computed if the variety has no torus factor"))
    end

    f = map_from_torusinvariant_cartier_divisor_group_to_torusinvariant_weil_divisor_group(v)
    g = map_from_torusinvariant_weil_divisor_group_to_class_group(v)
    return f * g
end

# overwritten from Oscar
@attr GrpAbFinGenMap function map_from_torusinvariant_cartier_divisor_group_to_picard_group(v::AbstractNormalToricVariety)
    # check input
    if has_torusfactor(v)
        throw(ArgumentError("Group of the torus-invariant Cartier divisors can only be computed if the variety has no torus factor"))
    end
    
    f = restrict_codomain(map_from_torusinvariant_cartier_divisor_group_to_class_group(v))
    return f * inv(snf(codomain(f))[2])
end

@attr GrpAbFinGenMap function map_from_picard_group_to_class_group(v::AbstractNormalToricVariety)
    f = image(map_from_torusinvariant_cartier_divisor_group_to_class_group(v))[2]
    g = snf(domain(f))[2] * f
    return hom(picard_group(v), class_group(v), matrix(g))
end

@attr ZZRingElem function gorenstein_index(v::AbstractNormalToricVariety)
    @req is_q_gorenstein(v) "gorenstein index can only be computed for Q-gorenstein varieties"
    c = divisor_class(canonical_divisor_class(v))
    f = cokernel(map_from_picard_group_to_class_group(v))[2]
    order(f(c))
end

@attr ZZRingElem function picard_index(v::AbstractNormalToricVariety) 
    @req is_simplicial(v) "picard index can only be computed for simplicial varieties"
    return order(cokernel(map_from_picard_group_to_class_group(v))[1]) 
end


#################################################
# Local class groups
#################################################

@attr local_class_groups(X :: AbstractNormalToricVariety) =
Dict([(c, class_group(U)) for (c,U) in affine_toric_charts(X)])

local_class_group(X :: AbstractNormalToricVariety, c :: Vector{Int64}) =
local_class_groups(X)[c]

@attr function maps_from_class_group_to_local_class_groups(X :: AbstractNormalToricVariety)
    K, f = cokernel(map_from_character_lattice_to_torusinvariant_weil_divisor_group(X))
    maps = Dict{Vector{Int}, GrpAbFinGenMap}()
    for c in maximal_cones_indices(X)
        U = affine_toric_chart(X, c)
        KU, fU = cokernel(map_from_character_lattice_to_torusinvariant_weil_divisor_group(U))
        m = zero_matrix(ZZ, nrays(X), nrays(U))
        for i in 1:length(c)
            m[c[i],i] = 1
        end
        f = snf(K)[2] * hom(K, KU, m) * inv(snf(KU)[2])
        maps[c] = hom(class_group(X), local_class_group(X,c), matrix(f))
    end
    return maps
end

map_from_class_group_to_local_class_group(X :: AbstractNormalToricVariety, c :: Vector{Int64}) =
maps_from_class_group_to_local_class_groups(X)[c]

@attr function local_gorenstein_indices(X :: AbstractNormalToricVariety)
    gorenstein_indices = Dict{Vector{Int}, ZZRingElem}()
    K = divisor_class(canonical_divisor_class(X))
    for c in maximal_cones_indices(X)
        f = map_from_class_group_to_local_class_group(X, c)
        gorenstein_indices[c] = order(f(K))
    end
    return gorenstein_indices
end

local_gorenstein_index(X :: AbstractNormalToricVariety, c :: Vector{Int64}) =
local_gorenstein_indices(X)[c]


#################################################
# Cones in the rational class group
#################################################


@attr effective_cone(X :: AbstractNormalToricVariety) =
positive_hull(transpose(degree_matrix_free_part(X)))

@attr function moving_cone(X :: AbstractNormalToricVariety)
    Q0 = degree_matrix_free_part(X)
    n = nrays(X)
    intersect([positive_hull(transpose(Q0[:,c])) for c in powerset(1:n, n-1, n-1)])
end

@attr function semiample_cone(X :: AbstractNormalToricVariety)
    Q0 = degree_matrix_free_part(X)
    intersect([positive_hull(transpose(Q0[:,c])) for c in covering_collection(X)])
end

    

