var documenterSearchIndex = {"docs":
[{"location":"database_functionality.html#Database-functionality","page":"Database functionality","title":"Database functionality","text":"","category":"section"},{"location":"database_functionality.html","page":"Database functionality","title":"Database functionality","text":"CStarSurfaces.jl has the ability to interact with database connections for saving and retrieving Mori dream spaces and their properties. The interface here is generic, but currently only an SQLite database holding SurfaceWithTorusAction's is supported.","category":"page"},{"location":"database_functionality.html","page":"Database functionality","title":"Database functionality","text":"A connection to the online ldp-database is planned.","category":"page"},{"location":"database_functionality.html","page":"Database functionality","title":"Database functionality","text":"DatabaseAdapter\nSQLiteAdapter\nSQLiteAdapterSurfaces\nimport_from_database\nfind_in_database\ndefault_column_functions\ndefault_insert_predicate\nexport_to_database\nupdate_in_database","category":"page"},{"location":"database_functionality.html#CStarSurfaces.DatabaseAdapter","page":"Database functionality","title":"CStarSurfaces.DatabaseAdapter","text":"DatabaseAdapter{T <: MoriDreamSpace}\n\nAbstract type of a database adapter holding objects of a common subtype of MoriDreamSpace. Subtypes of DatabaseAdapter{T} should at least implement the following functions:\n\nimport_from_database, find_in_database.\n\nIf the database is writeable, the following functions should be implemented as well:\n\nexport_to_database, update_in_database.\n\n\n\n\n\n","category":"type"},{"location":"database_functionality.html#CStarSurfaces.SQLiteAdapter","page":"Database functionality","title":"CStarSurfaces.SQLiteAdapter","text":"SQLiteAdapter{T} <: DatabaseAdapter{T}\n\nAn adapter to an SQLite database holding objects of type T where T <: MoriDreamSpace. The type T should at least implement the following methods (see their docstrings for more information):\n\ndefault_column_functions, find_in_database, sqlite_import_row.\n\n\n\n\n\n","category":"type"},{"location":"database_functionality.html#CStarSurfaces.SQLiteAdapterSurfaces","page":"Database functionality","title":"CStarSurfaces.SQLiteAdapterSurfaces","text":"SQLiteAdapterSurfaces = SQLiteAdapter{SurfaceWithTorusAction}\n\nAn adapter to an SQLite database holding objects of type SurfaceWithTorusAction.\n\n\n\n\n\n","category":"type"},{"location":"database_functionality.html#CStarSurfaces.import_from_database","page":"Database functionality","title":"CStarSurfaces.import_from_database","text":"import_from_database(db :: SQLiteAdapter{T}, sql :: String = \"TRUE\") where {T <: MoriDreamSpace}\n\nReturn a list of objects of type T that match a given sql query. The string sql is used after the WHERE in a SELECT statement, hence can contain restrictions on the columns as well as an ORDER BY and a LIMIT clause.\n\n\n\n\n\nimport_from_database(db :: SQLiteAdapter{T}, ids :: AbstractVector{Int}) where {T <: MoriDreamSpace}\n\nReturn the list of objects of type T from an SQLite database with the given ids.\n\n\n\n\n\nimport_from_database(db :: SQLiteAdapter{T}, id :: Int) where {T <: MoriDreamSpace}\n\nReturn the object of type T from an SQLite database with the given id.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.find_in_database","page":"Database functionality","title":"CStarSurfaces.find_in_database","text":"find_in_database(db :: SQLiteAdapterSurfaces, X :: SurfaceWithTorusAction)\n\nTries to find a SurfaceWithTorusAction in an SQLite database. If the surface is in the database, this function returns its id. Otherwise, it returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.default_column_functions","page":"Database functionality","title":"CStarSurfaces.default_column_functions","text":"default_column_functions(::Type{T}) where {T <: MoriDreamSpace}\n\nReturns a Dict{Symbol, Function} that serves as a default for the  names of the columns to export and how to export them for a given  subtype of MoriDreamSpace. Should be implemented by all subtypes of MoriDreamSpace where database functionality is desired.\n\nThe fallback definition for a general T returns an empty dictionary.\n\n\n\n\n\ndefault_column_functions(::Type{<:SurfaceWithTorusAction})\n\nThe default columns names and how to compute them when exporting objects of type SurfaceWithTorusAction to an SQLite database. \n\nThe function names all have the prefix _db_ followed by the name of the column, for instance CStarSurfaces._db_gen_matrix (they are not exported by default). They basically wrap the corresponding attribute function, giving the result as a language-agnostic string for database storage instead of a Julia type.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.default_insert_predicate","page":"Database functionality","title":"CStarSurfaces.default_insert_predicate","text":"default_insert_predicate(::Type{T}) where {T <: MoriDreamSpace}\n\nReturns a function of type (db :: SQLiteAdapter{T}, X :: T) -> Bool that serves as the default insert predicate when exporting objects of type T to an SQLite database. The default implementation returns true if and only if find_in_database(db, X) returns nothing, hence avoiding duplicate entries in the database. Note that there is no default implementation for find_in_database, it has to be implemented for each subtype of MoriDreamSpace where database functionality is desired.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.export_to_database","page":"Database functionality","title":"CStarSurfaces.export_to_database","text":"export_to_database(db_adapter :: SQLiteAdapter{T}, Xs :: AbstractVector; kwargs...) where {T <: MoriDreamSpace}\n\nExport a list Xs of varieties of type T to an SQLite database. The following keyword arguments are supported:\n\ncolumn_functions: Defaults to default_column_functions(T). A dictionary of type Dict{Symbol, Function} containing for each exported column name a function that tells export_to_database how to compute that column. Each function takes an object of type T and returns an SQLite compatible data type (Int, Float, String or Nothing).\ninsert_predicate: Defaults to default_insert_predicate(T). A function of  type (db :: SQLiteAdapter{T}, X :: T) -> Bool. Only objects where this predicate evaluates to true are exported.\n\n\n\n\n\n","category":"function"},{"location":"database_functionality.html#CStarSurfaces.update_in_database","page":"Database functionality","title":"CStarSurfaces.update_in_database","text":"update_in_database(db :: SQLiteAdapter{T}, column_functions :: Dict{Symbol, <:Function}; sql :: String = \"TRUE\") where {T <: MoriDreamSpace}\n\nUpdate all rows in an SQLite database matching a given SQL query by recomputing the columns given by column_functions. See also export_from_database and import_from_database.\n\n\n\n\n\nupdate_in_database(db :: SQLiteAdapter{T}, ids :: AbstractVector{Int}, column_functions :: Dict{Symbol, <:Function})\n\nUpdate all rows in an SQLite database with the given ids by recomputing the columns given by column_functions. See also export_from_database and import_from_database.\n\n\n\n\n\nupdate_in_database(db :: SQLiteAdapter{T}, id :: Int, column_functions :: Dict{Symbol, <:Function}) where {T <: MoriDreamSpace}\n\nUpdate all rows in an SQLite database with the given id by recomputing the columns given by column_functions. See also export_from_database and import_from_database.\n\n\n\n\n\n","category":"function"},{"location":"docs_index.html","page":"Index","title":"Index","text":"","category":"page"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"CurrentModule = CStarSurfaces","category":"page"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"using CStarSurfaces, Oscar ","category":"page"},{"location":"surfaces_with_torus_action.html#Surfaces-with-torus-action","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"The two main Julia types in this packages are CStarSurface and ToricSurface. Some functionality also works for MoriDreamSpace's, an abstract type of which CStarSurface and ToricSurface are subtypes.","category":"page"},{"location":"surfaces_with_torus_action.html#Julia-types","page":"Surfaces with torus action","title":"Julia types","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"CStarSurfaceCase\nCStarSurface\nToricSurface\nSurfaceWithTorusAction","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.CStarSurfaceCase","page":"Surfaces with torus action","title":"CStarSurfaces.CStarSurfaceCase","text":"CStarSurfaceCase\n\nThe abstract supertype of the possible possible configurations of source and sink of a mathbbC^*-surface.\n\nThis type has the four subtypes EE, EP, PE and PP, named after the existence of elliptic fixed points and parabolic fixed point curves in the source and sink of a mathbbC^*-surface respectively.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.CStarSurface","page":"Surfaces with torus action","title":"CStarSurfaces.CStarSurface","text":"CStarSurface{T<:CStarSurfaceCase}\n\nA mathbbC^*-surface of case T <: CStarSurfaceCase. As a Julia type, it gets modeled by a stuct with fields l, d and case, where l and d are zero-indexed vectors of one-indexed vectors of integers and case is one of the four symbols :ee, :pe, :ep and :pp.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.ToricSurface","page":"Surfaces with torus action","title":"CStarSurfaces.ToricSurface","text":"ToricSurface\n\nA toric surface. As a Julia type, it gets modeled by a struct with a single field vs that stores the primitive generator of the rays of the two-dimensional complete fan describing the toric surface.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.SurfaceWithTorusAction","page":"Surfaces with torus action","title":"CStarSurfaces.SurfaceWithTorusAction","text":"SurfaceWithTorusAction = Union{CStarSurface, ToricSurface}\n\nJulia type for surfaces with a non-trivial torus action.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#Constructors","page":"Surfaces with torus action","title":"Constructors","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"cstar_surface(ls :: Vector{Vector{Int64}}, ds :: Vector{Vector{Int64}}, case :: Symbol)\ncstar_surface(P :: ZZMatrix)\ntoric_surface\ngen_matrix","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.cstar_surface-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}, Symbol}","page":"Surfaces with torus action","title":"CStarSurfaces.cstar_surface","text":"cstar_surface(ls :: Vector{Vector{Int64}}, ds :: Vector{Vector{Int64}}, case :: Symbol)\n\nConstruct a C-star surface from the integral vectors l_i=(l_i1  l_in_i) and d_i=(d_i1  d_in_i) and a given C-star surface case. The parameters ls and ds are given both given as a vector of vectors. They must be of the same length and satisfy gcd(ls[i][j], ds[i][j]) == 1 for all i and j. The parameter case can be one of the four symbols :ee, :pe, :ep, :pp.\n\nExample\n\nThe E_6 singular cubic.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\njulia> gen_matrix(X)\n[-3   -1   3   0]\n[-3   -1   0   2]\n[-2   -1   1   1]\n\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.cstar_surface-Tuple{ZZMatrix}","page":"Surfaces with torus action","title":"CStarSurfaces.cstar_surface","text":"cstar_surface(P :: ZZMatrix)\n\nConstruct a C-star surface from a generator matrix of the correct format. That is, P must be of one of the following forms:\n\nbeginarraylcclc\ntext(e-e)  \nbeginbmatrix\nL \nd\nendbmatrix \nqquad \ntext(p-e) \nbeginbmatrix\nL  0 \nd  1\nendbmatrix \n\ntext(e-p) \nbeginbmatrix\nL  0 \nd  -1\nendbmatrix \nqquad \ntext(p-p) \nbeginbmatrix\nL  0  0 \nd  1  -1\nendbmatrix\nendarray\n\nwhere for some integral vectors l_i=(l_i1  l_in_i) in mathbbZ^n_i_geq 0 and d_i=(d_i1  d_in_i) in mathbbZ^n_i with gcd(l_ij d_ij) = 1, we have\n\nL = beginbmatrix\n-l_0  l_1  dots  0 \nvdots   ddots  0 \n-l_0  0  dots  l_r\nendbmatrix \nqquad\nd = beginbmatrix\nd_0  dots  d_r\nendbmatrix\n\nExample\n\nThe E_6 singular cubic.\n\njulia> cstar_surface(ZZ[-3 -1 3 0 ; -3 -1 0 2 ; -2 -1 1 1])\nC-star surface of type (e-e)\n\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.toric_surface","page":"Surfaces with torus action","title":"CStarSurfaces.toric_surface","text":"toric_surface(vs :: Vector{Vector{T}})\n\nConstruct a toric surface from a list of integral vectors in two-dimensional space.\n\nExample\n\nThe 5-th Hirzebruch surface.\n\njulia> toric_surface([[1,0], [0,1], [-1,-5], [0,-1]])\nNormal toric surface\n\n\n\n\n\ntoric_surface(P :: ZZMatrix)\n\nConstruct a toric surface from an integral matrix, where the columns of the matrix are the rays of the describing fan.\n\nExample\n\nThe 5-th Hirzebruch surface.\n\njulia> toric_surface(ZZ[1 0 -1 0 ; 0 1 -17 -1])\nNormal toric surface\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.gen_matrix","page":"Surfaces with torus action","title":"CStarSurfaces.gen_matrix","text":"gen_matrix(X :: MoriDreamSpaceUnion)\n\nReturn the generator matrix of a Mori Dream Space X. The columns of this matrix are the rays of the fan of the canonical toric ambient variety of X.\n\nExample\n\njulia> gen_matrix(cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee))\n[-3   -1   3   0]\n[-3   -1   0   2]\n[-2   -1   1   1]\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#Class-group-and-Picard-group","page":"Surfaces with torus action","title":"Class group and Picard group","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"class_group(X :: MoriDreamSpace)\nclass_group_rank\nclass_group_torsion\nclass_group_torsion_order\nlocal_class_groups(X :: MoriDreamSpace)\nlocal_class_group(X :: MoriDreamSpace, c :: Vector{Int64})\nmaps_from_class_group_to_local_class_groups(X :: MoriDreamSpace)\nmap_from_class_group_to_local_class_group(X :: MoriDreamSpace, c :: Vector{Int64})\npicard_group(X :: MoriDreamSpace)\ndegree_matrix\ndegree_matrix_free_part\ndegree_matrix_torsion_part\ngorenstein_index(X :: MoriDreamSpace)\nlocal_gorenstein_indices\nlocal_gorenstein_index\npicard_index(X :: MoriDreamSpace)\nlocal_picard_indices\nlocal_picard_index\nis_factorial","category":"page"},{"location":"surfaces_with_torus_action.html#Hecke.class_group-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Hecke.class_group","text":"class_group(X :: MoriDreamSpace)\n\nReturn the class group of a Mori Dream Space.\n\nExample\n\njulia> class_group(cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee))\nGrpAb: Z/4 x Z\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.class_group_rank","page":"Surfaces with torus action","title":"CStarSurfaces.class_group_rank","text":"class_group_rank(X :: MoriDreamSpaceUnion)\n\nReturn the rank of the class group of a Mori Dream Space.\n\nExample\n\njulia> class_group_rank(cstar_surface([[1, 1], [2], [2]], [[-3, -4], [1], [1]], :pe))\n2\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.class_group_torsion","page":"Surfaces with torus action","title":"CStarSurfaces.class_group_torsion","text":"class_group_torsion(X :: MoriDreamSpaceUnion)\n\nReturn the list of elementary divisors that make up the torsion part of the class group of a Mori Dream Space.\n\nExample\n\njulia> class_group_torsion(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\n2-element Vector{ZZRingElem}:\n 2\n 6\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.class_group_torsion_order","page":"Surfaces with torus action","title":"CStarSurfaces.class_group_torsion_order","text":"class_group_torsion_order(X :: MoriDreamSpaceUnion)\n\nReturn the order of the torsion part of the class group of a Mori Dream Space.\n\nExample\n\njulia> class_group_torsion_order(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\n12\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.local_class_groups-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"CStarSurfaces.local_class_groups","text":"local_class_groups(X :: MoriDreamSpace)\n\nCompute the local class groups of a Mori Dream Space X. The result is  a dictionary indexed by the maximal cones of X.\n\nExample\n\njulia> local_class_groups(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\nDict{Vector{Int64}, GrpAbFinGen} with 3 entries:\n  [1, 3, 4] => Abelian group with structure: Z/2 x Z/18\n  [2, 3, 4] => Abelian group with structure: Z/2 x Z/6\n  [1, 2]    => Abelian group with structure: Z/12\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.local_class_group-Tuple{MoriDreamSpace, Vector{Int64}}","page":"Surfaces with torus action","title":"CStarSurfaces.local_class_group","text":"local_class_group(X :: MoriDreamSpace, c :: Vector{Int64})\n\nCompute the local class group of a Mori Dream Space X at a maximal cone c given by a vector of indices.\n\nExample\n\njulia> local_class_group(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee), [1, 2])\nGrpAb: Z/12\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.maps_from_class_group_to_local_class_groups-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"CStarSurfaces.maps_from_class_group_to_local_class_groups","text":"maps_from_class_group_to_local_class_groups(X :: MoriDreamSpace)\n\nCompute the canonical maps from the class group of a Mori Dream Space to  its local class groups. The result is a dictionary indexed by the maximal  cones of X.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.map_from_class_group_to_local_class_group-Tuple{MoriDreamSpace, Vector{Int64}}","page":"Surfaces with torus action","title":"CStarSurfaces.map_from_class_group_to_local_class_group","text":"map_from_class_group_to_local_class_group(X :: MoriDreamSpace, c :: Vector{Int64})\n\nCompute the canonical map from the class group of a Mori Dream Space X to its local class group at a cone c, given by a vector of indices.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Hecke.picard_group-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Hecke.picard_group","text":"picard_group(X :: MoriDreamSpace)\n\nReturn the Picard group of a Mori Dream Space.\n\nExample\n\njulia> picard_group(cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee))\nGrpAb: Z\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.degree_matrix","page":"Surfaces with torus action","title":"CStarSurfaces.degree_matrix","text":"degree_matrix(X :: MoriDreamSpaceUnion)\n\nReturn the degree matrix of a Mori Dream Space (often denoted as Q). The columns of this matrix are the degrees of the generator of the Cox Ring, which are elements of the divisor class group. Note that we write the torsion parts of these elements first (in the upper rows of the  degree matrix), and the free part after that (in the lower rows of the degree matrix).\n\nExample\n\njulia> degree_matrix(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\n[0   1   1   0]\n[0   4   1   5]\n[1   3   4   2]\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.degree_matrix_free_part","page":"Surfaces with torus action","title":"CStarSurfaces.degree_matrix_free_part","text":"degree_matrix_free_part(X :: MoriDreamSpaceUnion)\n\nThe free part of the degree matrix of a Mori Dream Space. By the convention in this package, these are the lower rows of degree_matrix(X).\n\nExample\n\njulia> degree_matrix_free_part(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\n[1   3   4   2]\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.degree_matrix_torsion_part","page":"Surfaces with torus action","title":"CStarSurfaces.degree_matrix_torsion_part","text":"degree_matrix_torsion_part(X :: MoriDreamSpaceUnion)\n\nThe torsion part of the degree matrix of a Mori Dream Space. By the convention in this package, these are the upper rows of degree_matrix(X).\n\nExample\n\njulia> degree_matrix_torsion_part(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\n[0   1   1   0]\n[0   4   1   5]\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#Oscar.gorenstein_index-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Oscar.gorenstein_index","text":"gorenstein_index(X :: MoriDreamSpace)\n\nReturn the Gorenstein index of a mathbbQ-Gorenstein Mori Dream Space.\n\nExample\n\njulia> gorenstein_index(cstar_surface([[1, 1], [11], [5]], [[0, -2], [9], [3]], :ee))\n78\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.local_gorenstein_indices","page":"Surfaces with torus action","title":"CStarSurfaces.local_gorenstein_indices","text":"local_gorenstein_indices(X :: MoriDreamSpaceUnion)\n\nReturn the local gorenstein indices of a Mori Dream Space. The result is a dictionary indexed by the maximal cones of X.\n\nExample\n\njulia> local_gorenstein_indices(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\nDict{Vector{Int64}, ZZRingElem} with 3 entries:\n  [1, 3, 4] => 9\n  [2, 3, 4] => 3\n  [1, 2]    => 2\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.local_gorenstein_index","page":"Surfaces with torus action","title":"CStarSurfaces.local_gorenstein_index","text":"local_gorenstein_index(X :: MoriDreamSpaceUnion, c :: Vector{Int64})\n\nReturn the local gorenstein index of a Mori Dream Space at a given cone c,  which must be given as a vector of ray indices.\n\nExample\n\njulia> local_gorenstein_index(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee), [1, 3, 4])\n9\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#Oscar.picard_index-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Oscar.picard_index","text":"picard_index(X :: MoriDreamSpace)\n\nReturn the index of the Picard group in the class group of a Mori Dream Space.\n\nExample\n\njulia> picard_index(cstar_surface([[1, 1], [7], [7]], [[0, -1], [3], [3]], :ee))\n42\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.local_picard_indices","page":"Surfaces with torus action","title":"CStarSurfaces.local_picard_indices","text":"local_picard_indices(X :: MoriDreamSpaceUnion)\n\nReturn the local picard indices of a Mori Dream Space. The result is a dictionary indexed by the maximal cones of X.\n\nExample\n\njulia> local_picard_indices(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee))\nDict{Vector{Int64}, ZZRingElem} with 3 entries:\n  [1, 3, 4] => 36\n  [2, 3, 4] => 12\n  [1, 2]    => 12\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.local_picard_index","page":"Surfaces with torus action","title":"CStarSurfaces.local_picard_index","text":"local_picard_index(X :: MoriDreamSpaceUnion, c :: Vector{Int64})\n\nReturn the local picard index of a Mori Dream Space at a given cone c,  which must be given as a vector of ray indices.\n\nExample\n\njulia> local_picard_index(cstar_surface([[2, 2], [2], [4]], [[3, -3], [1], [1]], :ee), [1, 3, 4])\n36\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.is_factorial","page":"Surfaces with torus action","title":"CStarSurfaces.is_factorial","text":"is_factorial(X :: MoriDreamSpace)\n\nDetermine if a Mori Dream Space has at most factorial singularities, i.e. its canonical toric ambient variety is smooth.\n\nExample\n\njulia> is_factorial(cstar_surface([[1, 1], [7], [7]], [[0, -1], [3], [3]], :ee))\nfalse\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#Divisors","page":"Surfaces with torus action","title":"Divisors","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"CStarSurfaceDivisor\ncstar_surface_divisor\nToricSurfaceDivisor\ntoric_surface_divisor\nSurfaceWithTorusActionDivisor\ncanonical_divisor(X :: MoriDreamSpace)\nanticanonical_divisor(X :: MoriDreamSpace)\ncanonical_divisor_class(X :: MoriDreamSpace)\nanticanonical_divisor_class(X :: MoriDreamSpace)\nBase.:*(d1 :: SurfaceWithTorusActionDivisor, d2 :: SurfaceWithTorusActionDivisor)","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.CStarSurfaceDivisor","page":"Surfaces with torus action","title":"CStarSurfaces.CStarSurfaceDivisor","text":"CStarSurfaceDivisor{T}\n\nA Weil divisor on a mathbbC^*-surface of type T <: CStarSurfaceCase.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.cstar_surface_divisor","page":"Surfaces with torus action","title":"CStarSurfaces.cstar_surface_divisor","text":"cstar_surface_divisor(X :: CStarSurface, coeffs :: Vector{<:Oscar.IntegerUnion})\n\nConstruct a divisor on a C-star surface as a linear combination of the the torus invariant prime divisors. \n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[2, 1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> D = cstar_surface_divisor(X, [0, 1, -1, 3])\nCStarSurfaceDivisor{EE}(C-star surface of type (e-e), Torus-invariant, non-prime divisor on a normal toric variety)\n\njulia> coefficients(D)\n4-element Vector{ZZRingElem}:\n 0\n 1\n -1\n 3\n\n\n\n\n\ncstar_surface_divisor(X :: CStarSurface, coeffs :: DoubleVector{<:Oscar.IntegerUnion})\n\nConstruct a divisor on a C-star surface as a linear combination of the the torus invariant prime divisors, where the coefficients are given following the double index notation.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[2, 1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> D = cstar_surface_divisor(X, DoubleVector([[0, 1], [-1], [3]]))\nCStarSurfaceDivisor{EE}(C-star surface of type (e-e), Torus-invariant, non-prime divisor on a normal toric variety)\n\njulia> coefficients(D)\n4-element Vector{ZZRingElem}:\n 0\n 1\n -1\n 3\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.ToricSurfaceDivisor","page":"Surfaces with torus action","title":"CStarSurfaces.ToricSurfaceDivisor","text":"ToricSurfaceDivisor\n\nA Weil divisor on a toric surface.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.toric_surface_divisor","page":"Surfaces with torus action","title":"CStarSurfaces.toric_surface_divisor","text":"toric_surface_divisor(X :: ToricSurface, coeffs :: Vector{S})\n\nConstruct a divisor on a toric surface as a linear combination of the the torus invariant prime divisors.\n\nExample\n\njulia> X = toric_surface([[1,0], [0,1], [-1,-5], [0,-1]])\nNormal toric surface\n\njulia> D = toric_surface_divisor(X, [1, 2, -1, 5])\nToricSurfaceDivisor(Normal toric surface, Torus-invariant, non-prime divisor on a normal toric variety)\n\njulia> coefficients(D)\n4-element Vector{ZZRingElem}:\n 1\n 2\n -1\n 5\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.SurfaceWithTorusActionDivisor","page":"Surfaces with torus action","title":"CStarSurfaces.SurfaceWithTorusActionDivisor","text":"SurfaceWithTorusActionDivisor = Union{CStarSurfaceDivisor, ToricSurfaceDivisor}\n\nA Weil divisor on a surface with non-trivial torus action.\n\n\n\n\n\n","category":"type"},{"location":"surfaces_with_torus_action.html#Hecke.canonical_divisor-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Hecke.canonical_divisor","text":"canonical_divisor(X :: MoriDreamSpace)\n\nReturn the canonical divisor of a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> coefficients(canonical_divisor(X))\n4-element Vector{ZZRingElem}:\n -1\n -1\n 1\n -1\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Oscar.anticanonical_divisor-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Oscar.anticanonical_divisor","text":"anticanonical_divisor(X :: MoriDreamSpace)\n\nReturn the anticanonical divisor of a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> coefficients(anticanonical_divisor(X))\n4-element Vector{ZZRingElem}:\n 1\n 1\n -1\n 1\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Oscar.canonical_divisor_class-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Oscar.canonical_divisor_class","text":"canonical_divisor_class(X :: MoriDreamSpace)\n\nReturn the canonical divisor class of a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> divisor_class(canonical_divisor_class(X))\nElement of\nGrpAb: Z/4 x Z\nwith components [0 -2]\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Oscar.anticanonical_divisor_class-Tuple{MoriDreamSpace}","page":"Surfaces with torus action","title":"Oscar.anticanonical_divisor_class","text":"anticanonical_divisor_class(X :: MoriDreamSpace)\n\nReturn the anticanonical divisor class of a Mori Dream Space.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[0, -2], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> divisor_class(anticanonical_divisor_class(X))\nElement of\nGrpAb: Z/4 x Z\nwith components [0 2]\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Base.:*-Tuple{SurfaceWithTorusActionDivisor, SurfaceWithTorusActionDivisor}","page":"Surfaces with torus action","title":"Base.:*","text":"Base.:*(d1 :: SurfaceWithTorusActionDivisor, d2 :: SurfaceWithTorusActionDivisor)\n\nReturn the intersection number of two divisors on a surface with torus action. The divisors have to be defined on the same variety.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> D = cstar_surface_divisor(X, [1, 0, 2, -1])\nCStarSurfaceDivisor{EE}(C-star surface of type (e-e), Torus-invariant, non-prime divisor on a normal toric variety)\n\njulia> D * D\n4//3\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#Intersection-numbers","page":"Surfaces with torus action","title":"Intersection numbers","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"intersection_matrix\nanticanonical_self_intersection","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.intersection_matrix","page":"Surfaces with torus action","title":"CStarSurfaces.intersection_matrix","text":"intersection_matrix(X :: ToricSurface)\n\nReturn the matrix of intersection numbers of all toric prime divisors of a toric surface X with each other. The result is a rational n x n matrix, where n = nrays(X) and the (i,j)-th entry is the intersection number of the toric prime divisors associated to the i-th and j-th ray respectively.\n\nExample\n\njulia> intersection_matrix(toric_surface(ZZ[1 0 -1 0 ; 0 1 -17 -1]))\n[0    1   0     1]\n[1   17   1     0]\n[0    1   0     1]\n[1    0   1   -17]\n\n\n\n\n\nintersection_matrix(X :: CStarSurface)\n\nReturn the matrix of intersection numbers of all restrictions of toric prime divisors of a C-star surface X with each other. The result is a rational n x n matrix, where n = nrays(X) and the (i,j)-th entry is the intersection number of the toric prime divisors associated to the i-th and j-th ray respectively.\n\nExample\n\njulia> intersection_matrix(cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee))\n[1//3   1   2//3   1]\n[   1   3      2   3]\n[2//3   2   4//3   2]\n[   1   3      2   3]\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.anticanonical_self_intersection","page":"Surfaces with torus action","title":"CStarSurfaces.anticanonical_self_intersection","text":"anticanonical_self_intersection(X :: SurfaceWithTorusAction)\n\nReturn the self intersection number of the anticanonical divisor on a surface with torus action.\n\nExample\n\njulia> anticanonical_self_intersection(cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee))\n3\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#Resolution-of-singularities","page":"Surfaces with torus action","title":"Resolution of singularities","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"canonical_resolution\nexceptional_rays\ndiscrepancies\nmaximal_log_canonicity","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.canonical_resolution","page":"Surfaces with torus action","title":"CStarSurfaces.canonical_resolution","text":"canonical_resolution(X :: ToricSurface)\n\nReturn the canonical resolution of singularities of a toric surface X. The result is a triple (Y, ex_rays, discrepancies) where Y is the smooth toric surface in the resolution of singularities of X, ex_rays contains the rays of the exceptional divisors in the resolution and discrepancies contains their discrepancies.\n\nExample\n\njulia> X = toric_surface(ZZ[1 1 -3 ; 0 4 -7])\nNormal toric surface\n\njulia> (Y, ex, discr) = canonical_resolution(X);\n\njulia> gen_matrix(Y)\n[1   1   -3   1   1   1   0   -1   -2   -1    0]\n[0   4   -7   1   2   3   1   -2   -5   -3   -1]\n\njulia> ex\n3-element Vector{Vector{Vector{Int64}}}:\n [[1, 1], [1, 2], [1, 3]]\n [[0, 1], [-1, -2]]\n [[-2, -5], [-1, -3], [0, -1]]\n\njulia> discr\n3-element Vector{Vector{Rational{Int64}}}:\n [0//1, 0//1, 0//1]\n [-1//5, -2//5]\n [-1//7, -2//7, -3//7]\n\n\n\n\n\ncanonical_resolution(X :: CStarSurface)\n\nReturn the canonical resolution of singularities of a C-star surface surface X. The result is a triple (Y, ex_rays, discrepancies) where Y is the smooth C-star surface in the resolution of singularities of X, ex_rays contains the rays of the exceptional divisors in the resolution and discrepancies contains their discrepancies. ex_rays and discrepancies itself are given as pairs, where the first entry comes from the toric step and the second entry from the tropical step. The first entry is given as a DoubleVector, adhering to the double index notation of C-star surfaces.\n\nExample\n\nResolution of singularities of the E_6 singular cubic surface.\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> (Y, (ex_toric, ex_tropic), (discr_toric, discr_tropic)) = canonical_resolution(X);\n\njulia> gen_matrix(Y)\n[-3   -1   -1   -2   3   1   2   1   0   0   0   0    0]\n[-3   -1   -1   -2   0   0   0   0   2   1   1   0    0]\n[-2   -1    0   -1   1   1   1   0   1   1   0   1   -1]\n\njulia> ex_toric\n3-element DoubleVector{Vector{Vector{Int64}}} with indices ZeroRange(3):\n [[[1, 0], [2, -1]], [], []]\n [[[1, 1], [2, 1]], [[1, 0]]]\n [[[1, 1]], [[1, 0]]]\n\njulia> ex_tropic\n2-element Vector{Vector{Int64}}:\n [0, 1]\n [0, -1]\n\njulia> discr_toric\n3-element DoubleVector{Vector{Rational{Int64}}} with indices ZeroRange(3):\n [[0//1, 0//1], [], []]\n [[0//1, 0//1], [1//1]]\n [[0//1], [2//1]]\n\njulia> discr_tropic\n2-element Vector{Rational{Int64}}:\n 0//1\n 4//1\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.exceptional_rays","page":"Surfaces with torus action","title":"CStarSurfaces.exceptional_rays","text":"exceptional_rays(X :: SurfaceWithTorusAction)\n\nReturn the rays associated to the exceptional divisors in the resolution of singularities of a surface with torus action.\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.discrepancies","page":"Surfaces with torus action","title":"CStarSurfaces.discrepancies","text":"discrepancies(X :: SurfaceWithTorusAction)\n\nReturn the discrepancies associated to the exceptional divisors in the resolution of singularities of a surface with torus action.\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.maximal_log_canonicity","page":"Surfaces with torus action","title":"CStarSurfaces.maximal_log_canonicity","text":"maximal_log_canonicity(X :: ToricSurface)\n\nGiven a toric surface X, return the maximal rational number varepsilon such  that X is varepsilon-log canonical. By definition, this is the minimal  discrepancy in the resolution of singularities plus one.\n\nExample\n\njulia> X = toric_surface(ZZ[1 1 -3 ; 0 4 -7])\nNormal toric surface\n\njulia> maximal_log_canonicity(X)\n4//7\n\n\n\n\n\nmaximal_log_canonicity(X :: CStarSurface)\n\nGiven a C-star surface X, return the maximal rational number varepsilon such that X is varepsilon-log canonical. By definition, this is the minimal discrepancy in the resolution of singularities plus one.\n\nExample\n\njulia> maximal_log_canonicity(cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee))\n1//1\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#Attributes-of-\\mathbb{C}*-surfaces","page":"Surfaces with torus action","title":"Attributes of mathbbC^*-surfaces","text":"","category":"section"},{"location":"surfaces_with_torus_action.html","page":"Surfaces with torus action","title":"Surfaces with torus action","text":"canonical_toric_ambient(X :: CStarSurface)\ncox_ring_vars(X :: CStarSurface)\ncox_ring_relations(X :: CStarSurface)\nhas_x_plus(X :: CStarSurface)\nhas_x_minus(X :: CStarSurface)\nhas_D_plus(X :: CStarSurface)\nhas_D_minus(X :: CStarSurface)\nnblocks\nblock_sizes\nnumber_of_parabolic_fixed_point_curves\nslopes\nis_intrinsic_quadric\ncox_ring_vars","category":"page"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.canonical_toric_ambient-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.canonical_toric_ambient","text":"canonical_toric_ambient(X :: CStarSurface)\n\nConstruct the canonical toric ambient of a C-star surface, as an Oscar type.\n\nExample\n\njulia> X = cstar_surface([[3, 1], [3], [2]], [[-2, -1], [1], [1]], :ee)\nC-star surface of type (e-e)\n\njulia> Z = canonical_toric_ambient(X)\nNormal toric variety\n\njulia> rays(Z)\n4-element SubObjectIterator{RayVector{QQFieldElem}}:\n [-1, -1, -2//3]\n [-1, -1, -1]\n [1, 0, 1//3]\n [0, 1, 1//2]\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.cox_ring_vars-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.cox_ring_vars","text":"cox_ring_vars(X :: CStarSurface)\n\nReturn the variables in the Cox Ring of the canonical toric ambient of a C-star surface, following the double index notation. The result is a tuple, whose first entry is a DoubleVector consisting of the variables T[i][j] and whose second entry is the Vector of variables [S[1], ... S[m]],  where m is the number of parabolic fixed point curves.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[-3, -4], [1], [1]], :pe)\nC-star surface of type (p-e)\n\njulia> (Ts, Ss) = cox_ring_vars(X);\n\njulia> Ts\n3-element DoubleVector{MPolyDecRingElem} with indices ZeroRange(3):\n [T[0][1], T[0][2]]\n [T[1][1]]\n [T[2][1]]\n\njulia> Ss\n1-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n S[1]\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.cox_ring_relations-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.cox_ring_relations","text":"cox_ring_relations(X :: CStarSurface)\n\nReturn the list of relations in the Cox Ring of a C-star surface. Note that  these are all trinomials.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[-3, -4], [1], [1]], :pe)\nC-star surface of type (p-e)\n\njulia> cox_ring_relations(X)\n1-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n T[0][1]*T[0][2] + T[1][1]^2 + T[2][1]^2\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.has_x_plus-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.has_x_plus","text":"has_x_plus(X :: CStarSurface{<:CStarSurfaceCase})\n\nChecks whether a given C-star surface has an elliptic fixed point in the source, commonly denoted x^+.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.has_x_minus-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.has_x_minus","text":"has_x_minus(X :: CStarSurface{<:CStarSurfaceCase})\n\nChecks whether a given C-star surface has an elliptic fixed point in the sink, commonly denoted x^-.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.has_D_plus-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.has_D_plus","text":"has_D_plus(X :: CStarSurface{<:CStarSurfaceCase})\n\nChecks whether a given C-star surface has a parabolic fixed point curve in the source, commonly denoted D^+.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.has_D_minus-Tuple{CStarSurface}","page":"Surfaces with torus action","title":"CStarSurfaces.has_D_minus","text":"has_D_minus(X :: CStarSurface{<:CStarSurfaceCase})\n\nChecks whether a given C-star surface has a parabolic fixed point curve in the sink, commonly denoted D^-.\n\n\n\n\n\n","category":"method"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.nblocks","page":"Surfaces with torus action","title":"CStarSurfaces.nblocks","text":"nblocks(X :: CStarSurface)\n\nReturns the number of blocks in the generator matrix of a C-star surface.\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.block_sizes","page":"Surfaces with torus action","title":"CStarSurfaces.block_sizes","text":"block_sizes(X :: CStarSurface)\n\nReturns the sizes of the blocks in the generator matrix of a C-star surface. The result is a zero-indexed vector of type ZeroVector.\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.number_of_parabolic_fixed_point_curves","page":"Surfaces with torus action","title":"CStarSurfaces.number_of_parabolic_fixed_point_curves","text":"number_of_parabolic_fixed_point_curves(X :: CStarSurface)\n\nReturns the number of parabolic fixed point curves of a C-star surface.\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.slopes","page":"Surfaces with torus action","title":"CStarSurfaces.slopes","text":"slopes(X :: CStarSurface)\n\nReturns the DoubleVector of slopes of a C-star surface, i.e a DoubleVector with slopes(X)[i][j] = X.d[i][j] // X.l[i][j].\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.is_intrinsic_quadric","page":"Surfaces with torus action","title":"CStarSurfaces.is_intrinsic_quadric","text":"is_intrinsic_quadric(X :: CStarSurface)\n\nChecks whether a C-star surface is an intrinsic quadric, i.e its Cox Ring has a single quadratic relation.\n\n\n\n\n\n","category":"function"},{"location":"surfaces_with_torus_action.html#CStarSurfaces.cox_ring_vars","page":"Surfaces with torus action","title":"CStarSurfaces.cox_ring_vars","text":"cox_ring_vars(X :: CStarSurface)\n\nReturn the variables in the Cox Ring of the canonical toric ambient of a C-star surface, following the double index notation. The result is a tuple, whose first entry is a DoubleVector consisting of the variables T[i][j] and whose second entry is the Vector of variables [S[1], ... S[m]],  where m is the number of parabolic fixed point curves.\n\nExample\n\njulia> X = cstar_surface([[1, 1], [2], [2]], [[-3, -4], [1], [1]], :pe)\nC-star surface of type (p-e)\n\njulia> (Ts, Ss) = cox_ring_vars(X);\n\njulia> Ts\n3-element DoubleVector{MPolyDecRingElem} with indices ZeroRange(3):\n [T[0][1], T[0][2]]\n [T[1][1]]\n [T[2][1]]\n\njulia> Ss\n1-element Vector{MPolyDecRingElem{QQFieldElem, QQMPolyRingElem}}:\n S[1]\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#Normal-forms","page":"Normal forms","title":"Normal forms","text":"","category":"section"},{"location":"admissible_operations.html#Normal-form-of-toric-surfaces","page":"Normal forms","title":"Normal form of toric surfaces","text":"","category":"section"},{"location":"admissible_operations.html","page":"Normal forms","title":"Normal forms","text":"CStarSurfaces.normal_form(X :: ToricSurface)\nCStarSurfaces.is_normal_form(X :: ToricSurface)\nare_isomorphic(X :: ToricSurface, Y :: ToricSurface)","category":"page"},{"location":"admissible_operations.html#CStarSurfaces.normal_form-Tuple{ToricSurface}","page":"Normal forms","title":"CStarSurfaces.normal_form","text":"normal_form(X :: ToricSurface)\n\nBring a toric surface into normal form. Here, we call a toric surface with generator matrix P in normal form, if and only if:\n\nP in Hermite normal form,\nneighbouring columns in P are adjacent rays (i.e. the columns are   sorted either clockwise or counterclockwise),\nP is lexicographically minimal among all generator matrices satisfying 1. and 2.\n\nThese properties are enough to ensure that that two toric surfaces X and Y are isomorphic if and only if gen_matrix(normal_form(X)) == gen_matrix(normal_form(Y)).\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#CStarSurfaces.is_normal_form-Tuple{ToricSurface}","page":"Normal forms","title":"CStarSurfaces.is_normal_form","text":"is_normal_form(X :: ToricSurface)\n\nCheck whether a toric surface is in normal form.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#CStarSurfaces.are_isomorphic-Tuple{ToricSurface, ToricSurface}","page":"Normal forms","title":"CStarSurfaces.are_isomorphic","text":"are_isomorphic(X :: ToricSurface, Y :: ToricSurface)\n\nCheck whether two toric surfaces are isomorphic to each other.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#Types-of-admissible-operations","page":"Normal forms","title":"Types of admissible operations","text":"","category":"section"},{"location":"admissible_operations.html","page":"Normal forms","title":"Normal forms","text":"AdmissibleOperation\nInvertLastRow\nInvertLastRow(factor :: Int)\nPermutationOfRays\nPermutationOfBlocks\nAdmissibleRowOperation\nCompositeAdmissibleOperation\nnormalize_admissible_operation(γ :: CompositeAdmissibleOperation)","category":"page"},{"location":"admissible_operations.html#CStarSurfaces.AdmissibleOperation","page":"Normal forms","title":"CStarSurfaces.AdmissibleOperation","text":"AdmissibleOperation\n\nAbstract Julia type for admissible operations on C-star surfaces. All subtypes T <: AdmissibleOperation should at least implement the following functions:\n\n(α :: T)(X :: CStarSurface)\nBase.:*(α :: T, β :: T)\nBase.one(α :: T)\nBase.one(::Type{T})\nBase.inv(α :: T)\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.InvertLastRow","page":"Normal forms","title":"CStarSurfaces.InvertLastRow","text":"InvertLastRow <: AdmissibleOperation\n\nJulia type for an admissible operation that may or may not invert the last row in the generator matrix of a C-star surface. Geometrically, this means swapping source and sink of the C-star action.\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.InvertLastRow-Tuple{Int64}","page":"Normal forms","title":"CStarSurfaces.InvertLastRow","text":"InvertLastRow(factor :: Int)\n\nConstruct an admissible operation that multiplies the last row of the generator matrix of a C-star surface by factor, which can take the values 1 and -1.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#CStarSurfaces.PermutationOfRays","page":"Normal forms","title":"CStarSurfaces.PermutationOfRays","text":"PermutationOfRays <: AdmissibleOperation\n\nJulia type for an admissible operation that permutes rays within the blocks of the generator matrix of C-star surfaces. Only permutations that are local to each block are permitted.\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.PermutationOfBlocks","page":"Normal forms","title":"CStarSurfaces.PermutationOfBlocks","text":"PermutationOfBlocks <: AdmissibleOperation\n\nJulia type for an admissible operation that permutes the blocks of the generator matrix of a C-star surface.\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.AdmissibleRowOperation","page":"Normal forms","title":"CStarSurfaces.AdmissibleRowOperation","text":"AdmissibleRowOperation <: AdmissibleOperation\n\nJulia type for an admissible operation that adds integral multiples of the  upper rows of the generator matrix of a C-star surface to its last row.\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.CompositeAdmissibleOperation","page":"Normal forms","title":"CStarSurfaces.CompositeAdmissibleOperation","text":"CompositeAdmissibleOperation <: AdmissibleOperation\n\nJulia type for an admissible operation that arises as the composition of multiple admissible operations.\n\n\n\n\n\n","category":"type"},{"location":"admissible_operations.html#CStarSurfaces.normalize_admissible_operation-Tuple{CompositeAdmissibleOperation}","page":"Normal forms","title":"CStarSurfaces.normalize_admissible_operation","text":"normalize_admissible_operation(γ :: CompositeAdmissibleOperation)\n\nNormalize a composite admissible operation by reordering the steps and merging multiple operations of the same kind into one. The resulting CompositeAdmissibleOperation is guaranteed to consist of at most four admissible operations in the following order:\n\nInvertLastRow, PermutationOfRays, PermutationOfBlocks, AdmissibleRowOperation.\n\nIf only one type of operation remains, that operation is returned instead.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#Normal-form-of-\\mathbb{C}*-surfaces","page":"Normal forms","title":"Normal form of mathbbC^*-surfaces","text":"","category":"section"},{"location":"admissible_operations.html","page":"Normal forms","title":"Normal forms","text":"beta_plus\nbeta_minus\nbeta_plus_sorted\nbeta_minus_sorted\norientation\nCStarSurfaces.normal_form(X :: CStarSurface)\nCStarSurfaces.is_normal_form(X :: CStarSurface)\nare_isomorphic(X :: CStarSurface, Y :: CStarSurface)","category":"page"},{"location":"admissible_operations.html#CStarSurfaces.beta_plus","page":"Normal forms","title":"CStarSurfaces.beta_plus","text":"beta_plus(X :: CStarSurface)\n\nReturn a β :: DoubleVector with entries β[i][j] == slopes(X)[i][j] - floor(maximum(slopes(X)[i]))\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#CStarSurfaces.beta_minus","page":"Normal forms","title":"CStarSurfaces.beta_minus","text":"beta_minus(X :: CStarSurface)\n\nReturn a β :: DoubleVector with entries β[i][j] == ceil(minimum(slopes(X)[i])) - slopes(X)[i][j].\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#CStarSurfaces.beta_plus_sorted","page":"Normal forms","title":"CStarSurfaces.beta_plus_sorted","text":"beta_plus_sorted(X :: CStarSurface)\n\nReturn the sorted beta_plus(X). Each vector in beta_plus(X) are individually sorted and the vectors themselves are sorted by first by size and then lexicographically.\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#CStarSurfaces.beta_minus_sorted","page":"Normal forms","title":"CStarSurfaces.beta_minus_sorted","text":"beta_minus_sorted(X :: CStarSurface)\n\nReturn the sorted beta_minus(X). Each vector in beta_minus(X) are individually sorted and the vectors themselves are sorted by first by size and then lexicographically.\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#CStarSurfaces.orientation","page":"Normal forms","title":"CStarSurfaces.orientation","text":"orientation(X :: CStarSurface)\n\nReturn the orientation of a C-star surface. This function takes the values 1, 0 or -1. Note that orientation is not an isomorphy invariant, as applying InvertLastRow(-1) inverts the orientation of a C-star surface. All other types of AdmissibleOperation's leave the orientation invariant.\n\nA C-star surface X has orientation 1, if and only if one of the following conditions hold:\n\nX.case == :pe,\nX.case ∈ [:ee, :pp] and m_plus(X) > m_minus(X),\nX.case ∈ [:ee, :pp] and m_plus(X) == m_minus(X) and beta_plus_sorted(X) > beta_minus_sorted(X).\n\nSimilarly, X has orientation -1 if and only if one of the following conditions hold:\n\nX.case == :ep,\nX.case ∈ [:ee, :pp] and m_plus(X) < m_minus(X),\nX.case ∈ [:ee, :pp] and m_plus(X) == m_minus(X) and beta_plus_sorted(X) < beta_minus_sorted(X).\n\nThe remaining case is that X.case ∈ [:ee, :pp] and m_plus(X) == m_minus(X) and beta_plus_sorted(X) == beta_minus_sorted(X), in which case X has orientation 0.\n\n\n\n\n\n","category":"function"},{"location":"admissible_operations.html#CStarSurfaces.normal_form-Tuple{CStarSurface}","page":"Normal forms","title":"CStarSurfaces.normal_form","text":"normal_form(X :: CStarSurface)\n\nCompute the normal form of a C-star surface. Here, a C-star surface X is said to be in normal form, if and only if the following properties hold:\n\norientation(X) ≠ -1,\nbeta_plus(X) == beta_plus_sorted(X),\n0 ≤ X.d[i][1] < X.l[i][i] for all 1 ≤ i ≤ r, where r+1 == nblocks(X).\n\nThe third condition can also be phrased as floor(maximum(slopes(X)[i])) == 0 for all 1 ≤ i ≤ r.\n\nThe algorithm works by applying an InvertLastRow operation to achieve 1., then applying PermutationOfRays and PermutationOfBlocks operations to achieve 2. and finally, applying an AdmissibleRowOperation to achieve 3. Together, these properties are enough to ensure that X and Y are isomorphic if and only if they have the same normal form.\n\nThis function then returns a pair (Y, α), where Y is a C-star surface in normal form and α is an admissible operation with α(X) == Y.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#CStarSurfaces.is_normal_form-Tuple{CStarSurface}","page":"Normal forms","title":"CStarSurfaces.is_normal_form","text":"is_normal_form(X :: CStarSurface) = normal_form(X)[1] == X\n\nCheck whether a C-star surface is in normal form, see the docstring of normal_form.\n\n\n\n\n\n","category":"method"},{"location":"admissible_operations.html#CStarSurfaces.are_isomorphic-Tuple{CStarSurface, CStarSurface}","page":"Normal forms","title":"CStarSurfaces.are_isomorphic","text":"are_isomorphic(X :: CStarSurface, Y :: CStarSurface)\n\nCheck whether two C-star surfaces are isomorphic to each other. This function returns a pair, where the first entry is a boolean and the second entry is either nothing or an admissible operation turning X into Y.\n\n\n\n\n\n","category":"method"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = CStarSurfaces","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using CStarSurfaces, Oscar ","category":"page"},{"location":"index.html#CStarSurfaces.jl","page":"Home","title":"CStarSurfaces.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A computer algebra package for rational mathbbC^*-surfaces in the Julia programming language. This package makes use of the OSCAR Computer Algebra System.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The approach to mathbbC^*-surfaces relies on the general combinatorial theory of varieties with finitely generated Cox ring developed in [1], [2] and its specialization to varieties with torus action initiated in [3] and [4]. As an introductory reference, we mention [5].","category":"page"},{"location":"index.html#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The following invariants can be computed for mathbbC^*-surfaces and toric surfaces:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"divisor class group, local class groups, (anti)canonical divisor class,\nCox Ring, Gorenstein index, Picard index,\nintersection numbers, anticanonical self intersection,\nresolution of singularities, exceptional divisors, discrepancies, log canonicity,\nnormal form of defining data, admissible operations, isomorphy test.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Furthermore, some functionality to save and retrieve mathbbC^*-surfaces from a database is provided, see also the ldp-database.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"CStarSurfaces.jl is available in the General Registry, hence can be installed by typing ]add CStarSurfaces into a Julia REPL.","category":"page"},{"location":"index.html#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"We work in the notation of [5, Section 5.4].","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Import both Oscar and CStarSurfaces.jl to get started:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Oscar, CStarSurfaces","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"There are essentially two constructors for C-Star surfaces: The first takes the integral vectors l_i=(l_i1 dots l_in_i) and d_i=(d_i1 dots d_in_i) and one of the four symbols :ee, :pe, :ep, :pp. The second takes the generating matrix P of the correct shape:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"X = cstar_surface([[1, 1], [4], [4]], [[0, -2], [3], [3]], :ee)\nY = cstar_surface(ZZ[-1 -1 4 0 ; -1 -1 0 4 ; 0 -2 3 3])\nX == Y","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"gen_matrix returns the generating matrix (P-Matrix) of a C-star surface:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"gen_matrix(X)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"canonical_toric_ambient returns the canonical toric ambient variety of a C-star surface, as an Oscar type:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Z = canonical_toric_ambient(X)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We compute some geometric invariants of X:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"class_group(X)\ncox_ring(X)\ngorenstein_index(X)\npicard_index(X)\nK = anticanonical_divisor(X)\nK * K # the anticanonical self intersection\n(Xreg, exceptional_divisors, discrepancies) = canonical_resolution(X)\ngen_matrix(Xreg)\nmaximal_log_canonicity(X)","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"<div class=\"citation canonical\"><dl><dt>[1]</dt>\n<dd>\n<div id=\"BeHa07\">F. Berchtold and J. Hausen. <a href='https://doi.org/10.1090/S0002-9947-06-03904-3'><i>Cox rings and combinatorics</i></a>. <a href='https://doi.org/10.1090/S0002-9947-06-03904-3'>Trans. Amer. Math. Soc. <b>359</b>, 1205–1252 (2007)</a>.</div>\n</dd><dt>[2]</dt>\n<dd>\n<div id=\"Ha08\">J. Hausen. <a href='https://doi.org/10.17323/1609-4514-2008-8-4-711-757'><i>Cox rings and combinatorics. II</i></a>. <a href='https://doi.org/10.17323/1609-4514-2008-8-4-711-757'>Mosc. Math. J. <b>8</b>, 711–757, 847 (2008)</a>.</div>\n</dd><dt>[3]</dt>\n<dd>\n<div id=\"HaHe13\">J. Hausen and E. Herppich. <i>Factorially graded rings of complexity one</i>. In: Torsors, étale homotopy and applications to rational\n              points, editors, 414–428. Cambridge Univ. Press, Cambridge (2013).</div>\n</dd><dt>[4]</dt>\n<dd>\n<div id=\"HaSu10\">J. Hausen and H. Süß. <a href='https://doi.org/10.1016/j.aim.2010.03.010'><i>The Cox ring of an algebraic variety with torus action</i></a>. <a href='https://doi.org/10.1016/j.aim.2010.03.010'>Adv. Math. <b>225</b>, 977–1012 (2010)</a>.</div>\n</dd><dt>[5]</dt>\n<dd>\n<div id=\"ArDeHaLa15\">I. Arzhantsev, U. Derenthal, J. Hausen and A. Laface. <i>Cox rings</i>. Cambridge University Press, Cambridge (2015).</div>\n</dd>\n</dl></div>","category":"page"},{"location":"mori_dream_spaces.html#Mori-Dream-Spaces","page":"Mori Dream Spaces","title":"Mori Dream Spaces","text":"","category":"section"},{"location":"mori_dream_spaces.html","page":"Mori Dream Spaces","title":"Mori Dream Spaces","text":"This package is a about mathbbC^*-surfaces. However, some algorithms here also work for a more general class of varieties admitting a certain embedding into a toric variety, called Mori dream spaces. To allow for the treatment of these varieties in the future, this package provides the abstract MoriDreamSpace type, whose only implementations currently are CStarSurface and ToricSurface.","category":"page"},{"location":"mori_dream_spaces.html","page":"Mori Dream Spaces","title":"Mori Dream Spaces","text":"MoriDreamSpace\nMoriDreamSpaceUnion\ncanonical_toric_ambient\ncox_ring_relations\ncox_ring(X :: MoriDreamSpace)\nis_toric(X :: MoriDreamSpace)\nrays(X :: MoriDreamSpace)\nnrays(X :: MoriDreamSpace)\nmaximal_cones(X :: MoriDreamSpace)\nmaximal_cones_indices(X :: MoriDreamSpace)","category":"page"},{"location":"mori_dream_spaces.html#CStarSurfaces.MoriDreamSpace","page":"Mori Dream Spaces","title":"CStarSurfaces.MoriDreamSpace","text":"MoriDreamSpace\n\nJulia type for Mori Dream Spaces.\n\nSubtypes of MoriDreamSpace should at least implement the following methods:\n\ncanonical_toric_ambient(X :: MoriDreamSpace)\n\ncox_ring_relations(X :: MoriDreamSpace)\n\n\n\n\n\n","category":"type"},{"location":"mori_dream_spaces.html#CStarSurfaces.MoriDreamSpaceUnion","page":"Mori Dream Spaces","title":"CStarSurfaces.MoriDreamSpaceUnion","text":"MoriDreamSpaceUnion\n\nThe union of MoriDreamSpace and Oscar's NormalToricVarietyType.\n\n\n\n\n\n","category":"type"},{"location":"mori_dream_spaces.html#CStarSurfaces.canonical_toric_ambient","page":"Mori Dream Spaces","title":"CStarSurfaces.canonical_toric_ambient","text":"canonical_toric_ambient(X :: MoriDreamSpace)\n\nConstruct the canonical toric ambient variety of a Mori Dream Space.\n\nThis function should be implemented by all subtypes of MoriDreamSpace\n\n\n\n\n\n","category":"function"},{"location":"mori_dream_spaces.html#CStarSurfaces.cox_ring_relations","page":"Mori Dream Spaces","title":"CStarSurfaces.cox_ring_relations","text":"cox_ring_relations(X :: MoriDreamSpace)\n\nReturn the list of relations in the Cox Ring of a Mori Dream Space. Here, a relation is a RingElem whose parent is the Cox Ring of the canonical toric ambient variety.\n\nThis function should be implemented by all subtypes of MoriDreamSpace.\n\n\n\n\n\n","category":"function"},{"location":"mori_dream_spaces.html#Oscar.cox_ring-Tuple{MoriDreamSpace}","page":"Mori Dream Spaces","title":"Oscar.cox_ring","text":"cox_ring(X :: MoriDreamSpace)\n\nCompute the Cox Ring of a Mori Dream Space.\n\n\n\n\n\n","category":"method"},{"location":"mori_dream_spaces.html#CStarSurfaces.is_toric-Tuple{MoriDreamSpace}","page":"Mori Dream Spaces","title":"CStarSurfaces.is_toric","text":"is_toric(X :: MoriDreamSpace)\n\nCheck whether a Mori Dream Space is a toric variety.\n\n\n\n\n\n","category":"method"},{"location":"mori_dream_spaces.html#Oscar.rays-Tuple{MoriDreamSpace}","page":"Mori Dream Spaces","title":"Oscar.rays","text":"rays(X :: MoriDreamSpace)\n\nReturn the rays of the canonical toric ambient variety of a Mori Dream Space.\n\n\n\n\n\n","category":"method"},{"location":"mori_dream_spaces.html#Oscar.nrays-Tuple{MoriDreamSpace}","page":"Mori Dream Spaces","title":"Oscar.nrays","text":"nrays(X :: MoriDreamSpace)\n\nReturn the number of rays of the canonical toric ambient variety of a Mori Dream Space.\n\n\n\n\n\n","category":"method"},{"location":"mori_dream_spaces.html#Oscar.maximal_cones-Tuple{MoriDreamSpace}","page":"Mori Dream Spaces","title":"Oscar.maximal_cones","text":"maximal_cones(X :: MoriDreamSpace)\n\nReturn the maximal cones of the fan of the canonical toric ambient variety of a Mori Dream Space.\n\n\n\n\n\n","category":"method"},{"location":"mori_dream_spaces.html#CStarSurfaces.maximal_cones_indices-Tuple{MoriDreamSpace}","page":"Mori Dream Spaces","title":"CStarSurfaces.maximal_cones_indices","text":"maximal_cones_indices(X :: MoriDreamSpaceUnion)\n\nReturn the list of maximal cones of a Mori Dream Space, where each cone is represented as a list of integers that are the indices of its generating rays in the fan.\n\n\n\n\n\n","category":"method"}]
}
